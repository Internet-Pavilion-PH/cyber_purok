import{A as D,R as pt,b as Ft,I as Ct,_ as dt,c as T,C as U}from"./index-UeNFZPFr.js";import{C as _t}from"./passPostProcess-A3LhX4bI.js";let W,Y;function H(A){W||(W=new Float32Array(1),Y=new Int32Array(W.buffer)),W[0]=A;const r=Y[0];let t=r>>16&32768,e=r>>12&2047;const o=r>>23&255;return o<103?t:o>142?(t|=31744,t|=(o==255?0:1)&&r&8388607,t):o<113?(e|=2048,t|=(e>>114-o)+(e>>113-o&1),t):(t|=o-112<<10|e>>1,t+=e&1,t)}function I(A){const r=(A&32768)>>15,t=(A&31744)>>10,e=A&1023;return t===0?(r?-1:1)*Math.pow(2,-14)*(e/Math.pow(2,10)):t==31?e?NaN:(r?-1:1)*(1/0):(r?-1:1)*Math.pow(2,t-15)*(1+e/Math.pow(2,10))}function Gt(A){const r=A.split("?")[0],t=r.lastIndexOf(".");return t>-1?r.substring(t).toLowerCase():""}D.prototype._partialLoadFile=function(A,r,t,e,o=null){const c=a=>{t[r]=a,t._internalCount++,t._internalCount===6&&e(t)},y=(a,i)=>{o&&a&&o(a.status+" "+a.statusText,i)};this._loadFile(A,c,void 0,void 0,!0,y)};D.prototype._cascadeLoadFiles=function(A,r,t,e=null){const o=[];o._internalCount=0;for(let c=0;c<6;c++)this._partialLoadFile(t[c],c,o,r,e)};D.prototype._cascadeLoadImgs=function(A,r,t,e,o=null,c){const y=[];y._internalCount=0;for(let a=0;a<6;a++)this._partialLoadImg(e[a],a,y,A,r,t,o,c)};D.prototype._partialLoadImg=function(A,r,t,e,o,c,y=null,a){const i=pt();Ft(A,l=>{t[r]=l,t._internalCount++,e&&e.removePendingData(i),t._internalCount===6&&c&&c(o,t)},(l,f)=>{e&&e.removePendingData(i),y&&y(l,f)},e?e.offlineProvider:null,a),e&&e.addPendingData(i)};D.prototype.createCubeTextureBase=function(A,r,t,e,o=null,c=null,y,a=null,i=!1,n=0,s=0,l=null,f=null,h=null,p=!1,F=null){const u=l||new Ct(this,7);u.isCube=!0,u.url=A,u.generateMipMaps=!e,u._lodGenerationScale=n,u._lodGenerationOffset=s,u._useSRGBBuffer=!!p&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!e),u!==l&&(u.label=A.substring(0,60)),this._doNotHandleContextLost||(u._extension=a,u._files=t,u._buffer=F);const _=A;this._transformTextureUrl&&!l&&(A=this._transformTextureUrl(A));const R=a??Gt(A),P=dt(R),m=(G,d)=>{u.dispose(),c?c(G,d):G&&T.Warn(G)},L=(G,d)=>{A===_?G&&m(G.status+" "+G.statusText,d):(T.Warn(`Failed to load ${A}, falling back to the ${_}`),this.createCubeTextureBase(_,r,t,!!e,o,m,y,a,i,n,s,u,f,h,p,F))};if(P)P.then(G=>{const d=b=>{f&&f(u,b),G.loadCubeData(b,u,i,o,(M,E)=>{m(M,E)})};F?d(F):t&&t.length===6?G.supportCascades?this._cascadeLoadFiles(r,b=>d(b.map(M=>new Uint8Array(M))),t,m):m("Textures type does not support cascades."):this._loadFile(A,b=>d(new Uint8Array(b)),void 0,r?r.offlineProvider||null:void 0,!0,L)});else{if(!t||t.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(r,u,(G,d)=>{h&&h(G,d)},t,m)}return this._internalTexturesCache.push(u),u};const ht=542327876,Z=131072,v=512,S=4,q=64,tt=131072;function N(A){return A.charCodeAt(0)+(A.charCodeAt(1)<<8)+(A.charCodeAt(2)<<16)+(A.charCodeAt(3)<<24)}function xt(A){return String.fromCharCode(A&255,A>>8&255,A>>16&255,A>>24&255)}const et=N("DXT1"),rt=N("DXT3"),at=N("DXT5"),$=N("DX10"),nt=113,ot=116,st=2,ft=10,mt=88,j=31,bt=0,Bt=1,it=2,lt=3,J=4,ct=7,K=20,ut=21,Rt=22,Ot=23,wt=24,Ut=25,It=26,Lt=28,gt=32;class C{static GetDDSInfo(r){const t=new Int32Array(r.buffer,r.byteOffset,j),e=new Int32Array(r.buffer,r.byteOffset,j+4);let o=1;t[it]&Z&&(o=Math.max(1,t[ct]));const c=t[ut],y=c===$?e[gt]:0;let a=0;switch(c){case nt:a=2;break;case ot:a=1;break;case $:if(y===ft){a=2;break}if(y===st){a=1;break}}return{width:t[J],height:t[lt],mipmapCount:o,isFourCC:(t[K]&S)===S,isRGB:(t[K]&q)===q,isLuminance:(t[K]&tt)===tt,isCube:(t[Lt]&v)===v,isCompressed:c===et||c===rt||c===at,dxgiFormat:y,textureType:a}}static _GetHalfFloatAsFloatRGBAArrayBuffer(r,t,e,o,c,y){const a=new Float32Array(o),i=new Uint16Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=I(i[f]),a[n+1]=I(i[f+1]),a[n+2]=I(i[f+2]),C.StoreLODInAlphaChannel?a[n+3]=y:a[n+3]=I(i[f+3]),n+=4}return a}static _GetHalfFloatRGBAArrayBuffer(r,t,e,o,c,y){if(C.StoreLODInAlphaChannel){const a=new Uint16Array(o),i=new Uint16Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=i[f],a[n+1]=i[f+1],a[n+2]=i[f+2],a[n+3]=H(y),n+=4}return a}return new Uint16Array(c,e,o)}static _GetFloatRGBAArrayBuffer(r,t,e,o,c,y){if(C.StoreLODInAlphaChannel){const a=new Float32Array(o),i=new Float32Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=i[f],a[n+1]=i[f+1],a[n+2]=i[f+2],a[n+3]=y,n+=4}return a}return new Float32Array(c,e,o)}static _GetFloatAsHalfFloatRGBAArrayBuffer(r,t,e,o,c,y){const a=new Uint16Array(o),i=new Float32Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++)a[n]=H(i[n]),a[n+1]=H(i[n+1]),a[n+2]=H(i[n+2]),C.StoreLODInAlphaChannel?a[n+3]=H(y):a[n+3]=H(i[n+3]),n+=4;return a}static _GetFloatAsUIntRGBAArrayBuffer(r,t,e,o,c,y){const a=new Uint8Array(o),i=new Float32Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=U(i[f])*255,a[n+1]=U(i[f+1])*255,a[n+2]=U(i[f+2])*255,C.StoreLODInAlphaChannel?a[n+3]=y:a[n+3]=U(i[f+3])*255,n+=4}return a}static _GetHalfFloatAsUIntRGBAArrayBuffer(r,t,e,o,c,y){const a=new Uint8Array(o),i=new Uint16Array(c,e);let n=0;for(let s=0;s<t;s++)for(let l=0;l<r;l++){const f=(l+s*r)*4;a[n]=U(I(i[f]))*255,a[n+1]=U(I(i[f+1]))*255,a[n+2]=U(I(i[f+2]))*255,C.StoreLODInAlphaChannel?a[n+3]=y:a[n+3]=U(I(i[f+3]))*255,n+=4}return a}static _GetRGBAArrayBuffer(r,t,e,o,c,y,a,i,n){const s=new Uint8Array(o),l=new Uint8Array(c,e);let f=0;for(let h=0;h<t;h++)for(let p=0;p<r;p++){const F=(p+h*r)*4;s[f]=l[F+y],s[f+1]=l[F+a],s[f+2]=l[F+i],s[f+3]=l[F+n],f+=4}return s}static _ExtractLongWordOrder(r){return r===0||r===255||r===-16777216?0:1+C._ExtractLongWordOrder(r>>8)}static _GetRGBArrayBuffer(r,t,e,o,c,y,a,i){const n=new Uint8Array(o),s=new Uint8Array(c,e);let l=0;for(let f=0;f<t;f++)for(let h=0;h<r;h++){const p=(h+f*r)*3;n[l]=s[p+y],n[l+1]=s[p+a],n[l+2]=s[p+i],l+=3}return n}static _GetLuminanceArrayBuffer(r,t,e,o,c){const y=new Uint8Array(o),a=new Uint8Array(c,e);let i=0;for(let n=0;n<t;n++)for(let s=0;s<r;s++){const l=s+n*r;y[i]=a[l],i++}return y}static UploadDDSLevels(r,t,e,o,c,y,a=-1,i,n=!0){let s=null;o.sphericalPolynomial&&(s=[]);const l=!!r.getCaps().s3tc;t.generateMipMaps=c;const f=new Int32Array(e.buffer,e.byteOffset,j);let h,p,F,u=0,_,R,P,m,L=0,G=1;if(f[bt]!==ht){T.Error("Invalid magic number in DDS header");return}if(!o.isFourCC&&!o.isRGB&&!o.isLuminance){T.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(o.isCompressed&&!l){T.Error("Compressed textures are not supported on this platform.");return}let d=f[Rt];_=f[Bt]+4;let b=!1;if(o.isFourCC)switch(h=f[ut],h){case et:G=8,L=33777;break;case rt:G=16,L=33778;break;case at:G=16,L=33779;break;case nt:b=!0,d=64;break;case ot:b=!0,d=128;break;case $:{_+=20;let B=!1;switch(o.dxgiFormat){case ft:b=!0,d=64,B=!0;break;case st:b=!0,d=128,B=!0;break;case mt:o.isRGB=!0,o.isFourCC=!1,d=32,B=!0;break}if(B)break}default:T.Error(["Unsupported FourCC code:",xt(h)]);return}const M=C._ExtractLongWordOrder(f[Ot]),E=C._ExtractLongWordOrder(f[wt]),Q=C._ExtractLongWordOrder(f[Ut]),At=C._ExtractLongWordOrder(f[It]);b&&(L=r._getRGBABufferInternalSizedFormat(o.textureType)),P=1,f[it]&Z&&c!==!1&&(P=Math.max(1,f[ct]));const yt=i||0,k=r.getCaps();for(let B=yt;B<y;B++){for(p=f[J],F=f[lt],m=0;m<P;++m){if(a===-1||a===m){const x=a===-1?m:0;if(!o.isCompressed&&o.isFourCC){t.format=5,u=p*F*4;let O=null;if(r._badOS||r._badDesktopOS||!k.textureHalfFloat&&!k.textureFloat)d===128?(O=C._GetFloatAsUIntRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,x),s&&x==0&&s.push(C._GetFloatRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,x))):d===64&&(O=C._GetHalfFloatAsUIntRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,x),s&&x==0&&s.push(C._GetHalfFloatAsFloatRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,x))),t.type=0;else{const X=k.textureFloat&&(n&&k.textureFloatLinearFiltering||!n),z=k.textureHalfFloat&&(n&&k.textureHalfFloatLinearFiltering||!n),V=(d===128||d===64&&!z)&&X?1:(d===64||d===128&&!X)&&z?2:0;let g,w=null;switch(d){case 128:{switch(V){case 1:g=C._GetFloatRGBAArrayBuffer,w=null;break;case 2:g=C._GetFloatAsHalfFloatRGBAArrayBuffer,w=C._GetFloatRGBAArrayBuffer;break;case 0:g=C._GetFloatAsUIntRGBAArrayBuffer,w=C._GetFloatRGBAArrayBuffer;break}break}default:{switch(V){case 1:g=C._GetHalfFloatAsFloatRGBAArrayBuffer,w=null;break;case 2:g=C._GetHalfFloatRGBAArrayBuffer,w=C._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:g=C._GetHalfFloatAsUIntRGBAArrayBuffer,w=C._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}t.type=V,O=g(p,F,e.byteOffset+_,u,e.buffer,x),s&&x==0&&s.push(w?w(p,F,e.byteOffset+_,u,e.buffer,x):O)}O&&r._uploadDataToTextureDirectly(t,O,B,x)}else if(o.isRGB)t.type=0,d===24?(t.format=4,u=p*F*3,R=C._GetRGBArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,M,E,Q),r._uploadDataToTextureDirectly(t,R,B,x)):(t.format=5,u=p*F*4,R=C._GetRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,M,E,Q,At),r._uploadDataToTextureDirectly(t,R,B,x));else if(o.isLuminance){const O=r._getUnpackAlignement(),X=p;u=Math.floor((p+O-1)/O)*O*(F-1)+X,R=C._GetLuminanceArrayBuffer(p,F,e.byteOffset+_,u,e.buffer),t.format=1,t.type=0,r._uploadDataToTextureDirectly(t,R,B,x)}else u=Math.max(4,p)/4*Math.max(4,F)/4*G,R=new Uint8Array(e.buffer,e.byteOffset+_,u),t.type=0,r._uploadCompressedDataToTextureDirectly(t,L,p,F,R,B,x)}_+=d?p*F*(d/8):u,p*=.5,F*=.5,p=Math.max(1,p),F=Math.max(1,F)}if(i!==void 0)break}s&&s.length>0?o.sphericalPolynomial=_t.ConvertCubeMapToSphericalPolynomial({size:f[J],right:s[0],left:s[1],up:s[2],down:s[3],front:s[4],back:s[5],format:5,type:1,gammaSpace:!1}):o.sphericalPolynomial=void 0}}C.StoreLODInAlphaChannel=!1;export{C as DDSTools};
