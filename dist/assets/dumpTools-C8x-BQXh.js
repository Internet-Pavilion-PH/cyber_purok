const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-UeNFZPFr.js","assets/index-BzEWNIgQ.css","assets/pass.fragment-Dwr4VMpR.js"])))=>i.map(i=>d[i]);
import{C,T as m,n as d,c as _,f as E,o as A,E as x}from"./index-UeNFZPFr.js";let l=null;async function T(){const e=d.LastCreatedEngine?.createCanvas(100,100)??new OffscreenCanvas(100,100);e instanceof OffscreenCanvas&&_.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");const{ThinEngine:r}=await E(async()=>{const{ThinEngine:o}=await import("./index-UeNFZPFr.js").then(s=>s.t);return{ThinEngine:o}},__vite__mapDeps([0,1]));if(!r.IsSupported){if(!e.getContext("bitmaprenderer"))throw new Error("DumpData: No WebGL or bitmap rendering context available. Cannot dump data.");return{canvas:e}}const t={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1},a=new r(e,!1,t);d.Instances.pop(),d.OnEnginesDisposedObservable.add(o=>{a&&o!==a&&!a.isDisposed&&d.Instances.length===0&&y()}),a.getCaps().parallelShaderCompile=void 0;const f=new A(a),{passPixelShader:i}=await E(async()=>{const{passPixelShader:o}=await import("./pass.fragment-Dwr4VMpR.js");return{passPixelShader:o}},__vite__mapDeps([2,0,1])),c=new x({engine:a,name:i.name,fragmentShader:i.shader,samplerNames:["textureSampler"]});return{canvas:e,dumpEngine:{engine:a,renderer:f,wrapper:c}}}async function I(){return l||(l=T()),await l}async function v(e,r,t,a,f="image/png",i,c){const o=await t.readPixels(0,0,e,r),s=new Uint8Array(o.buffer);D(e,r,s,a,f,i,!0,void 0,c)}async function w(e,r,t,a="image/png",f,i=!1,c=!1,o){if(t instanceof Float32Array){const u=new Uint8Array(t.length);let n=t.length;for(;n--;){const p=t[n];u[n]=Math.round(C(p)*255)}t=u}const s=await I();return await new Promise(async u=>{if(s.dumpEngine){const n=s.dumpEngine;n.engine.setSize(e,r,!0);const p=n.engine.createRawTexture(t,e,r,5,!1,!i,1);n.renderer.setViewport(),n.renderer.applyEffectWrapper(n.wrapper),n.wrapper.effect._bindTexture("textureSampler",p),n.renderer.draw(),p.dispose()}else{const n=s.canvas.getContext("bitmaprenderer");s.canvas.width=e,s.canvas.height=r;const p=new ImageData(e,r);p.data.set(t);const g=await createImageBitmap(p,{premultiplyAlpha:"none",imageOrientation:i?"flipY":"from-image"});n.transferFromImageBitmap(g)}m.ToBlob(s.canvas,n=>{if(!n)throw new Error("DumpData: Failed to convert canvas to blob.");f!==void 0&&m.DownloadBlob(n,f);const p=new FileReader;p.onload=g=>{const h=g.target.result;u(h)},c?p.readAsArrayBuffer(n):p.readAsDataURL(n)},a,o)})}function D(e,r,t,a,f="image/png",i,c=!1,o=!1,s){i===void 0&&!a&&(i=""),w(e,r,t,f,i,c,o,s).then(u=>{a&&a(u)})}function y(){l&&(l?.then(e=>{e.canvas instanceof HTMLCanvasElement&&e.canvas.remove(),e.dumpEngine&&(e.dumpEngine.engine.dispose(),e.dumpEngine.renderer.dispose(),e.dumpEngine.wrapper.dispose())}),l=null)}const b={DumpData:D,DumpDataAsync:w,DumpFramebuffer:v,Dispose:y},R=()=>{m.DumpData=D,m.DumpDataAsync=w,m.DumpFramebuffer=v};R();export{y as Dispose,D as DumpData,w as DumpDataAsync,v as DumpFramebuffer,b as DumpTools};
